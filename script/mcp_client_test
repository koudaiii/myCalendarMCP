#!/bin/bash

# MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçµŒç”±ã§ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
# docs/05-call-methods-comparison.md#2-MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçµŒç”±ã®å‘¼ã³å‡ºã— ã®ã‚·ãƒŠãƒªã‚ªã«å¯¾å¿œ

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã«ç§»å‹•ã—ã¦uvã‚’ä½¿ã£ã¦Pythonã‚’å®Ÿè¡Œ
cd "$PROJECT_ROOT"

# Pythonã®å®Ÿè£…éƒ¨åˆ†ã‚’å®Ÿè¡Œ
exec uv run python3 - <<'EOF'
import asyncio
import json
import logging
import os
import signal
import subprocess
import sys
import time
from datetime import datetime, timedelta

# ãƒ­ã‚¬ãƒ¼ã®è¨­å®š
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

try:
    import EventKit
    EVENTKIT_AVAILABLE = True
    logger.info("âœ… EventKit ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒåˆ©ç”¨å¯èƒ½ã§ã™")
except ImportError:
    EVENTKIT_AVAILABLE = False
    logger.error("âŒ EventKit ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
    logger.error("   pyobjc-framework-EventKit ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãã ã•ã„")


def check_calendar_permission():
    """ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã‚’ç¢ºèª"""
    if not EVENTKIT_AVAILABLE:
        return False

    auth_status = EventKit.EKEventStore.authorizationStatusForEntityType_(
        EventKit.EKEntityTypeEvent
    )

    if auth_status == EventKit.EKAuthorizationStatusAuthorized:
        logger.info("âœ… ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒç¢ºèªã•ã‚Œã¾ã—ãŸ")
        return True
    else:
        logger.warning("âŒ ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™")
        logger.info("   ã¾ãš script/request_calendar_permission.py ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„")
        return False


class MCPServerManager:
    """MCPã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ãƒ»åœæ­¢ã‚’ç®¡ç†"""

    def __init__(self):
        self.process = None
        self.server_ready = False

    async def start_server(self, transport="stdio"):
        """MCPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•"""
        logger.info(f"ğŸš€ MCPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ä¸­... (transport: {transport})")

        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ«ãƒ¼ãƒˆã‹ã‚‰script/serverã‚’æŒ‡å®š
        script_path = os.path.join(os.getcwd(), "script", "server")

        if not os.path.exists(script_path):
            raise FileNotFoundError(f"ã‚µãƒ¼ãƒãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {script_path}")

        cmd = [script_path, "--transport", transport]
        logger.info(f"å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰: {' '.join(cmd)}")

        try:
            # stdio transport ã®å ´åˆã€ç›´æ¥é€šä¿¡ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ã‚»ã‚¹èµ·å‹•
            self.process = subprocess.Popen(
                cmd,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=0
            )

            # ã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã™ã‚‹ã¾ã§å°‘ã—å¾…æ©Ÿ
            await asyncio.sleep(2)

            if self.process.poll() is None:
                logger.info("âœ… MCPã‚µãƒ¼ãƒãƒ¼ãŒèµ·å‹•ã—ã¾ã—ãŸ")
                self.server_ready = True
                return True
            else:
                stderr_output = self.process.stderr.read()
                logger.error(f"âŒ MCPã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—: {stderr_output}")
                return False

        except Exception as e:
            logger.error(f"âŒ MCPã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def stop_server(self):
        """MCPã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢"""
        if self.process:
            logger.info("ğŸ›‘ MCPã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ä¸­...")
            self.process.terminate()
            try:
                self.process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("ã‚µãƒ¼ãƒãƒ¼ãŒå¿œç­”ã—ãªã„ãŸã‚å¼·åˆ¶çµ‚äº†ã—ã¾ã™")
                self.process.kill()
                self.process.wait()
            logger.info("âœ… MCPã‚µãƒ¼ãƒãƒ¼ãŒåœæ­¢ã—ã¾ã—ãŸ")
            self.server_ready = False


class MCPClient:
    """ç°¡å˜ãªMCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå®Ÿè£…"""

    def __init__(self, server_process):
        self.server_process = server_process
        self.request_id = 1
        self.initialized = False

    def send_request(self, method, params=None):
        """MCPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡"""
        request = {
            "jsonrpc": "2.0",
            "method": method,
            "id": self.request_id,
        }
        if params:
            request["params"] = params

        request_json = json.dumps(request)
        logger.info(f"ğŸ“¤ [OUTGOING] MCP REQUEST: {request_json}")

        try:
            # ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            self.server_process.stdin.write(request_json + "\n")
            self.server_process.stdin.flush()

            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’èª­ã¿å–ã‚Šï¼ˆè¤‡æ•°è¡Œã®å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€JSONãŒå®Œäº†ã™ã‚‹ã¾ã§èª­ã‚€ï¼‰
            response_line = ""
            while True:
                line = self.server_process.stdout.readline()
                if not line:
                    raise Exception("ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“")

                line = line.strip()
                # JSONRPCãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
                if line.startswith('{"jsonrpc":'):
                    response_line = line
                    break
                # ç©ºè¡Œã‚„ãƒ­ã‚°è¡Œã¯ã‚¹ã‚­ãƒƒãƒ—
                elif line == "" or not line.startswith("{"):
                    continue

            if not response_line:
                raise Exception("æœ‰åŠ¹ãªJSONRPCãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒå—ä¿¡ã§ãã¾ã›ã‚“ã§ã—ãŸ")

            response = json.loads(response_line)
            logger.info(f"ğŸ“¥ [INCOMING] MCP RESPONSE: {json.dumps(response, ensure_ascii=False, indent=2)}")

            self.request_id += 1
            return response

        except Exception as e:
            logger.error(f"âŒ MCPãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: {e}")
            return None

    def send_notification(self, method, params=None):
        """MCPãƒãƒ¼ãƒ†ã‚£ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ç„¡ã—ï¼‰"""
        notification = {
            "jsonrpc": "2.0",
            "method": method,
        }
        if params:
            notification["params"] = params

        notification_json = json.dumps(notification)
        logger.info(f"ğŸ“¤ [OUTGOING] MCP NOTIFICATION: {notification_json}")

        try:
            # ãƒãƒ¼ãƒ†ã‚£ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é€ä¿¡ï¼ˆãƒ¬ã‚¹ãƒãƒ³ã‚¹ç„¡ã—ï¼‰
            self.server_process.stdin.write(notification_json + "\n")
            self.server_process.stdin.flush()
            return True
        except Exception as e:
            logger.error(f"âŒ MCPãƒãƒ¼ãƒ†ã‚£ãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return False

    def initialize(self):
        """MCPã‚µãƒ¼ãƒãƒ¼ã‚’åˆæœŸåŒ–"""
        logger.info("ğŸ”§ MCPã‚µãƒ¼ãƒãƒ¼ã‚’åˆæœŸåŒ–ä¸­...")
        response = self.send_request("initialize", {
            "protocolVersion": "2024-11-05",
            "capabilities": {
                "roots": {"listChanged": True},
                "sampling": {}
            },
            "clientInfo": {
                "name": "mcp-client-test",
                "version": "1.0.0"
            }
        })

        if response and "result" in response:
            # åˆæœŸåŒ–å®Œäº†å¾Œã«initialized notificationã‚’é€ä¿¡
            logger.info("ğŸ”§ åˆæœŸåŒ–å®Œäº†é€šçŸ¥ã‚’é€ä¿¡ä¸­...")
            if self.send_notification("notifications/initialized"):
                self.initialized = True
                logger.info("âœ… MCPã‚µãƒ¼ãƒãƒ¼ã®åˆæœŸåŒ–ãŒå®Œäº†ã—ã¾ã—ãŸ")
                return True
            else:
                logger.error("âŒ åˆæœŸåŒ–å®Œäº†é€šçŸ¥ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸ")
                return False
        else:
            logger.error("âŒ MCPã‚µãƒ¼ãƒãƒ¼ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
            return False

    def list_tools(self):
        """åˆ©ç”¨å¯èƒ½ãªãƒ„ãƒ¼ãƒ«ä¸€è¦§ã‚’å–å¾—"""
        logger.info("ğŸ” åˆ©ç”¨å¯èƒ½ãªãƒ„ãƒ¼ãƒ«ä¸€è¦§ã‚’å–å¾—ä¸­...")
        return self.send_request("tools/list", {})

    def call_tool(self, tool_name, arguments):
        """ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã—"""
        logger.info(f"âš¡ ãƒ„ãƒ¼ãƒ« '{tool_name}' ã‚’å‘¼ã³å‡ºã—ä¸­...")
        return self.send_request("tools/call", {
            "name": tool_name,
            "arguments": arguments
        })

    def list_resources(self):
        """åˆ©ç”¨å¯èƒ½ãªãƒªã‚½ãƒ¼ã‚¹ä¸€è¦§ã‚’å–å¾—"""
        logger.info("ğŸ“‹ åˆ©ç”¨å¯èƒ½ãªãƒªã‚½ãƒ¼ã‚¹ä¸€è¦§ã‚’å–å¾—ä¸­...")
        return self.send_request("resources/list", {})

    def read_resource(self, uri):
        """ãƒªã‚½ãƒ¼ã‚¹ã‚’èª­ã¿å–ã‚Š"""
        logger.info(f"ğŸ“– ãƒªã‚½ãƒ¼ã‚¹ '{uri}' ã‚’èª­ã¿å–ã‚Šä¸­...")
        return self.send_request("resources/read", {
            "uri": uri
        })


async def run_mcp_client_scenario():
    """MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçµŒç”±ã®å‘¼ã³å‡ºã—ã‚·ãƒŠãƒªã‚ªã‚’å®Ÿè¡Œ"""

    logger.info("ğŸ¯ MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçµŒç”±ã®å‘¼ã³å‡ºã—ã‚·ãƒŠãƒªã‚ªã‚’é–‹å§‹")
    logger.info("=" * 60)

    # 1. ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼è¨±å¯ç¢ºèª
    logger.info("ğŸ“‹ Step 1: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ã‚’ç¢ºèª")
    if not check_calendar_permission():
        logger.error("âŒ ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™ã€‚çµ‚äº†ã—ã¾ã™ã€‚")
        return False

    # 2. MCPã‚µãƒ¼ãƒãƒ¼èµ·å‹•
    logger.info("ğŸ“‹ Step 2: MCPã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•")
    server_manager = MCPServerManager()

    try:
        if not await server_manager.start_server("stdio"):
            logger.error("âŒ MCPã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ")
            return False

        # 3. MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä½œæˆ
        logger.info("ğŸ“‹ Step 3: MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–")
        client = MCPClient(server_manager.process)

        # 4. MCPãƒ—ãƒ­ãƒˆã‚³ãƒ«åˆæœŸåŒ–
        logger.info("ğŸ“‹ Step 4: MCPãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚’åˆæœŸåŒ–")
        if not client.initialize():
            logger.error("âŒ MCPãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ")
            return False

        # 5. ãƒ„ãƒ¼ãƒ«ä¸€è¦§å–å¾—
        logger.info("ğŸ“‹ Step 5: åˆ©ç”¨å¯èƒ½ãªãƒ„ãƒ¼ãƒ«ä¸€è¦§ã‚’å–å¾—")
        tools_response = client.list_tools()
        if tools_response and "result" in tools_response:
            tools = tools_response["result"].get("tools", [])
            logger.info(f"âœ… {len(tools)} å€‹ã®ãƒ„ãƒ¼ãƒ«ãŒåˆ©ç”¨å¯èƒ½ã§ã™:")
            for tool in tools:
                logger.info(f"   - {tool.get('name', 'N/A')}: {tool.get('description', 'N/A')}")

        # 6. ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä¸€è¦§å–å¾—
        logger.info("ğŸ“‹ Step 6: ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä¸€è¦§ã‚’å–å¾—")
        calendars_response = client.call_tool("list_macos_calendars", {})
        if calendars_response and "result" in calendars_response:
            logger.info("âœ… ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä¸€è¦§å–å¾—æˆåŠŸ")

        # 7. ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—ï¼ˆä»Šæ—¥ã‹ã‚‰1é€±é–“ï¼‰
        logger.info("ğŸ“‹ Step 7: ã‚¤ãƒ™ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—ï¼ˆä»Šæ—¥ã‹ã‚‰1é€±é–“ï¼‰")
        start_date = datetime.now().strftime("%Y-%m-%d")
        end_date = (datetime.now() + timedelta(days=7)).strftime("%Y-%m-%d")

        events_response = client.call_tool("get_macos_calendar_events", {
            "start_date": start_date,
            "end_date": end_date
        })

        if events_response and "result" in events_response:
            logger.info("âœ… ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—æˆåŠŸ")

            # ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
            content = events_response["result"].get("content", [])
            if content and len(content) > 0:
                events_text = content[0].get("text", "")
                try:
                    events = json.loads(events_text)
                    logger.info(f"ğŸ“… {len(events)} ä»¶ã®ã‚¤ãƒ™ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ")

                    # ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤º
                    for i, event in enumerate(events, 1):
                        logger.info(f"   {i}. {event.get('title', 'N/A')}")
                        logger.info(f"      ğŸ“… {event.get('start_date', 'N/A')} - {event.get('end_date', 'N/A')}")
                        logger.info(f"      ğŸ“‹ ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼: {event.get('calendar', 'N/A')}")
                        if event.get('notes'):
                            logger.info(f"      ğŸ“ ãƒ¡ãƒ¢: {event.get('notes')}")
                        logger.info("")

                except json.JSONDecodeError:
                    logger.warning("âš ï¸ ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ")

        # 8. ãƒªã‚½ãƒ¼ã‚¹ä¸€è¦§å–å¾—
        logger.info("ğŸ“‹ Step 8: åˆ©ç”¨å¯èƒ½ãªãƒªã‚½ãƒ¼ã‚¹ä¸€è¦§ã‚’å–å¾—")
        resources_response = client.list_resources()
        if resources_response and "result" in resources_response:
            resources = resources_response["result"].get("resources", [])
            logger.info(f"âœ… {len(resources)} å€‹ã®ãƒªã‚½ãƒ¼ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã§ã™:")
            for resource in resources:
                logger.info(f"   - {resource.get('uri', 'N/A')}: {resource.get('name', 'N/A')}")

        # 9. ãƒªã‚½ãƒ¼ã‚¹èª­ã¿å–ã‚Šï¼ˆcalendar://eventsï¼‰
        logger.info("ğŸ“‹ Step 9: calendar://events ãƒªã‚½ãƒ¼ã‚¹ã‚’èª­ã¿å–ã‚Š")
        events_resource = client.read_resource("calendar://events")
        if events_resource and "result" in events_resource:
            logger.info("âœ… calendar://events ãƒªã‚½ãƒ¼ã‚¹èª­ã¿å–ã‚ŠæˆåŠŸ")

        logger.info("=" * 60)
        logger.info("ğŸ‰ MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçµŒç”±ã®å‘¼ã³å‡ºã—ã‚·ãƒŠãƒªã‚ªãŒå®Œäº†ã—ã¾ã—ãŸ")
        return True

    except Exception as e:
        logger.error(f"âŒ ã‚·ãƒŠãƒªã‚ªå®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
        return False

    finally:
        # ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢
        server_manager.stop_server()


def main():
    """ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œé–¢æ•°"""
    logger.info("ğŸš€ MCP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’é–‹å§‹")
    logger.info("docs/05-call-methods-comparison.md#2-MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆçµŒç”±ã®å‘¼ã³å‡ºã— ã®ã‚·ãƒŠãƒªã‚ª")
    logger.info("")

    # ã‚·ã‚°ãƒŠãƒ«ãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
    def signal_handler(signum, frame):
        logger.info("\nâš ï¸ ä¸­æ–­ã‚·ã‚°ãƒŠãƒ«ã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚çµ‚äº†ä¸­...")
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        # éåŒæœŸã§ã‚·ãƒŠãƒªã‚ªã‚’å®Ÿè¡Œ
        success = asyncio.run(run_mcp_client_scenario())

        if success:
            logger.info("âœ… ãƒ†ã‚¹ãƒˆãŒæ­£å¸¸ã«å®Œäº†ã—ã¾ã—ãŸ")
            sys.exit(0)
        else:
            logger.error("âŒ ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¾ã—ãŸ")
            sys.exit(1)

    except KeyboardInterrupt:
        logger.info("\nâš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã£ã¦ä¸­æ–­ã•ã‚Œã¾ã—ãŸ")
        sys.exit(1)
    except Exception as e:
        logger.error(f"âŒ äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
EOF
